### 4.4 MySQL数据库 -- MySQL查询优化
***

#### 查找分析查询速度慢的原因

**使用explain：**

> 别名：desc，用于分析单条SQL语句，会返回以下字段

| id | select_type | table | type | possible_keys | key | key_len | ref | rows | extra |
| :------: | :------: | :------: | :------: | :------: | :------: | :------: | :------: | :------: | :------: |

> 1. id：id相同，执行顺序由上至下；id不同，id的序号会递增，id值越大优先级越高，越先被执行。
> 2. select_type：主要是用于区别普通查询、联合查询、子查询等的复杂查询。
> 3. table：指的就是当前执行的表。
> 4. type： 显示的是查询使用了哪种访问类型。
> 5. possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。
> 6. key： 实际使用的索引。如果为NULL，则没有使用索引。
> 7. key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好。
> 8. ref：显示索引的哪一列被使用了。
> 9. rows：必须检查的用来返回请求数据的行数。
> 10. Extra：解析查询的额外信息。

> type：显示的是访问类型，是较为重要的一个指标

>> 常用从好到坏依次是：const > eq_ref > ref > range > index > ALL。一般来说，得保证查询至少达到range级别，最好能达到ref。
>>> const：表示通过索引一次就找到了。
>>>
>>> eq_ref ：唯一性索引扫描，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。
>>> 
>>> ref ：非唯一性索引扫描，返回匹配某个单独值的所有行，可能会找到多个符合条件的行。 
>>> 
>>> range：只检索给定范围的行，这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。
>>> 
>>> index： 索引全扫描。
>>> 
>>> ALL：全表扫描。

>extra：解析查询的额外信息常见说明

>> 只有using index：意思就是索引覆盖，查询的内容可以直接在索引中拿到。
>> 
>> 只有using where：表明虽然用到了索引，但是没有索引覆盖，产生了回表。
>> 
>> 同时有using where和using index：表明用到了索引，索引也覆盖了，using where只是过滤元组，和是否读取数据文件或索引文件没有关系。
>> 
>> 其它：出现using filesort、using temporary影响系统的性能需要优化。

**使用show profiles：**

> set profiling = 1 // 开启后，服务器执行的所有语句会记录下执行时间，并存放在临时表中
> 
> show profiles; // 展示临时表中记录的语句执行时间
> 
> show profile for query Query_ID; // 根据Query_ID查询SQL语句的耗时详情

```sql
mysql> set profiling = 1;
Query OK, 0 rows affected

mysql> show profiles;
+----------+-----------+-------------------+
| Query_ID | Duration  | Query             |
+----------+-----------+-------------------+
|        1 | 0.0003275 | set profiling = 1 |
+----------+-----------+-------------------+
1 row in set

mysql> use loan_org;
Database changed
mysql> select * from test;
+----+------+------------+----------+---------------------+---------------------+
| id | year | date       | time     | datetime            | timestamp           |
+----+------+------------+----------+---------------------+---------------------+
|  0 |    0 | 0000-00-00 | 00:00:00 | 0000-00-00 00:00:00 | 0000-00-00 00:00:00 |
|  1 |    0 | 0000-00-00 | 00:00:00 | 2015-01-01 22:22:22 | 2020-03-06 16:26:44 |
+----+------+------------+----------+---------------------+---------------------+
2 rows in set

mysql> show profiles;
+----------+-----------+--------------------+
| Query_ID | Duration  | Query              |
+----------+-----------+--------------------+
|        1 | 0.0003275 | set profiling = 1  |
|        2 |  0.000262 | use loan_org       |
|        3 | 0.0004535 | select * from test |
+----------+-----------+--------------------+
3 rows in set

mysql> show profile for query 3;
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000111 |
| checking permissions | 1.4E-5   |
| Opening tables       | 3.1E-5   |
| init                 | 2.6E-5   |
| System lock          | 1.4E-5   |
| optimizing           | 1.4E-5   |
| statistics           | 1.8E-5   |
| preparing            | 1.9E-5   |
| executing            | 1E-5     |
| Sending data         | 5.6E-5   |
| end                  | 1.2E-5   |
| query end            | 1.5E-5   |
| closing tables       | 1.5E-5   |
| freeing items        | 3.9E-5   |
| cleaning up          | 6.2E-5   |
+----------------------+----------+
15 rows in set

mysql> 
```

**使用show processlist：**

> 观察是否有大量线程处于不正常的状态或特征。

**记录慢查询日志：**

> 分析查询日志，不要直接打开慢查询日志进行分析，可以使用pt-query-digest工具进行分析。

#### 优化查询

**优化查询过程中的数据访问：**
> 首先看自己的SQL语句中是否满足以下三个条件：
> 1. 查询需要条数的记录，使用`limit`限制返回条数。
> 2. 需要哪些列就`SELECT`哪些列，避免`SELECT *`。
> 3. 重复查询相同数据时，可以缓存数据，下次直接读取缓存。
> 
> 如果上面三点不能解决问题，可使用`explain`分析SQL语句，看看是否扫描了大量数据但只返回了少数的行，可采用以下几点优化查询：
> 1. 使用索引覆盖扫描，把所有用到的列都放进索引，这样存储引擎不需要回表就可以返回结果集。
> 2. 改变数据库和表的结构，部分情况可以使用空间换时间，冗余常用字段，避免连表查询。
> 3. 重写SQL语句，让优化器可以以更优的方式执行查询。

**优化长难的查询语句：**

切分查询：

> 将一个大的查询分为多个小的相同的查询
> 
> 例如，一次性删除1000万条数据服务器开销很大，可以每次删除1万条并sleep一会，直至删除完成。

分解关联查询：

> 将一条关联查询语句分解成多条SQL来执行

**优化特定类型的查询语句：**

优化count()查询：

> 1. count(*)中的*表示忽略所有的列，直接统计列数，所以避免使用count(具体列名)这种方式。
> 2. 可以使用`EXPLAIN`查询扫表的近似值，用近似值替代count(*)。
> 3. 只用汇总表记录总数量，代替每次查询count(*)。
> 4. 缓存count(*)的值。

优化关联查询：

> 1. 确保`ON`或`USING`字句中的列上有索引，左连接确保右表连接字段有索引，右连接确保左边连接字段有索引，内连接则两表连接字段确保都有索引。
> 2. 确保`GROUP BY`、`ORDER BY`中只有一个表中的列，这样MySQL才有可能使用索引。

优化子查询：

> 尽量使用关联查询替代。

优化GROUP BY和DISTINCT：

> 1. 这两种查询建立索引都是最有效的优化方法。
> 2. 关联查询中，使用主键列或自增列进行`GROUP BY`效率更高。（？？资料看的，但是如果是主键列和自增列，有唯一性还分啥组？）
> 3. 如果`GROUP  BY`时不需要排序，可以加上`ORDER BY NULL`，MySQL将不进行文件排序。

优化limit分页：

> limit 在偏移量大的时候，查询效率低（一般还是移动偏移量靠谱，如果真出现这样的问题的话再考虑下面的方法）：
> 
> 可以记录上查询的最大ID，下次查询时使用条件限制，例：LIMIT 0,100 WHERE id > last_max_id;

优化UNION查询：

> UNION ALL 效率高于 UNION，可在业务中完成去重。

***
真题1：请简述项目中优化SQL语句执行效率的方法？

> 优化SQL语句主要从三方面入手：
> 1. 优化查询过程中的数据访问。
> 2. 优化长难SQL语句。
> 3. 优化特定类型SQL语句。
> 
> 具体措施参考一下上面的内容。

真题2：SQL语句的性能如何分析？

> 可以使用EXPLAIN关键字对SQL语句进行分析。
> 
> 具体字段含义参考上面的内容。

**下一小节：4.5 MySQL高可用&高可拓展**