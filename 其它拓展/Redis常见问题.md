## Redis
> 官方数据：能抗住100000+QPS

### Q：redis是啥语言实现的
> C语言（ANSI C）

### Q：redis 的String类型用啥实现的 
```C
// C语言实现，sds方式，通过预分配和惰性回收机制，不用每次都修改字符串都重新分配内存
struct sdshdr {
	// 记录 buf 数组中已使用字节的数量
	// 等于 SDS 所保存字符串的长度
	int len;
    // 记录 buf 数组中未使用字节的数量
    int free;

    // 字节数组，用于保存字符串
    char buf[];
};
```

### Q：为啥用Redis？
> 因为传统关系型数据库已经不能满足所有的应用场景了，一些流量访问高峰、热点数据等等，都很容易把数据库打崩，这时候就需要引入缓存中间件了。一般常见的缓存中间件有Memcached和Redis，对比后选择了Redis

### Q：Memcached和Redis区别？
> 1. Redis支持5种数据类型，Memcached只支持key-value结构
> 2. Redis支持事务
> 3. Redis支持数据持久化（RDB和AOF）
> 4. Redis只使用单核，而Memcached使用多核。所以平均在每一个核上，Redis在存储小数据时，效率更高。

### Q：Redis有哪些数据结构？特点是啥？
> String、Hash、List、Set、Sorted Set
> 
> String：做简单的k-v存储，常用于：缓存、计数器（微博点赞）等
> 
> Hash：存储结构化的数据，比如对象（前提是这个对象没有嵌套对象），可以直接操作hash里面的字段，由于生产中会出现对象嵌套对象的情况，这种数据类型我实际很少用。
> 
> List：有序列表，可以存储一些列表型的数据结构（粉丝列表，评论列表啥的），也可以轻松实现阻塞队列（lpush左侧插入、brpop右侧队尾阻塞式争抢消费，或者rpop非阻塞式消费，消费不到的时候要记得sleep一会再消费）
> 
> Set：无序集合，会自动去重，可以基于这个特性用来去重。也可以做集合的交、并、差集，完成一些应用场景（如两个人的好友集求交集，得到共同好友）。
> 
> Sorted Set：有序集合，自动去重且可以排序，写数据进去的时候给写个分数，自动根据分数排序。常用于各种排行榜（微博热搜）、带权重的队列（普通消息score=1，重要消息score=2），然后工作线程可以优先消费高score的任务。

### Q：Redis的缓存雪崩是啥，怎么避免？
> 缓存雪崩：是指`大量的缓存在同一时间失效`（很多缓存是定时任务去刷新的，就有可能出现同时失效的情况），导致大量请求直接打到数据库，数据库挂掉。
> 
> 如何避免：批量设置缓存时，可以使用`失效时间随机`的策略（在原本失效时间基础上加一个随机值），也可以设置`热点数据永不失效`（有更新直接更新，不设置失效时间）。

### Q：Redis的缓存穿透是啥，怎么避免？
> 缓存穿透：是指缓存和数据库中没有的数据，用户不断发起请求，比如数据库中的自增id都是从1开始，用户用id=-1来大量请求，不会命中缓存，这些请求会全部直达数据库，量大的恶意攻击有可能导致数据库挂机。
> 
> 如何避免：接口层增加`参数校验`，不合法参数直接return，避免这种不合理请求。还可以`网关层拉黑`单ip大量请求这种用户。
> 
> 高级解决方法：`布隆过滤器`，这个Redis Module过滤器利用高效的数据结构和算法可以快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新缓存再return。

### Q：Redis的缓存击穿是啥，怎么避免？
> 缓存击穿：是指缓存中某一个热点数据“特别热”，它抗住了大部分的并发，当这个热点数据在缓存中失效的瞬间，大量的请求直接打到数据库，导致数据库挂掉。就像是一张纸上被击穿了一个洞一样。
> 
> 怎么避免：`热点数据永不过期`，需要更新的时直接覆盖更新。或者对这种数据读库时加上互斥锁，成功查询并写入缓存后再释放锁，就能防止瞬间大量请求落到数据库上，从而避免击穿。

### Q：Redis分布式锁是怎么回事？
> 核心就是`setnx`(set if not exist)争抢锁，抢到之后用`expire`给锁加上过期时间，防止忘记释放。
 
### Q：如果执行setnx之后，执行expire命令之前，进程意外挂掉了，那会怎么样？

> 锁将得不到释放，所以可以利用set之类的复杂参数，把setnx和expire合成一条指令来用。

### Q：假设Redis里有1亿个key，其中10万个是以固定前缀开头的，如何将他们全找出来？
> 使用`keys`命令可以扫出指定模式的key列表。

### Q：如果这个Redis正在给线上提供服务，此时运行会发生什么？
> 此处引出核心考点：`Redis是单线程的`，keys命令会导致线程阻塞一段时间，这段时间内线上服务会停顿，直到命令执行完毕，线上才能恢复Redis服务。这时候我们可以用`scan`命令，scan命令可以非阻塞的扫出指定模式的key列表，但是有一定概率重复（可以在业务中去重）。

### Q：Redis如何做消息队列？
> 一般使用`List`数据类型来做消息队列，使用`lpush`入队，`rpop`出队，当rpop没有消息时，要适当sleep一会重试。

### Q：可不可以不用sleep呢？（Redis实现阻塞队列）
> 可以使用`brpop`出队，当没有消息时，它会阻塞直到消息的到来。

### Q：能不能一次生产多次消费呢？
> Redis支持`pub/sub（主题订阅者模式）`，支持1对N的消息队列。

### Q：那pub/sub模式有什么缺点呢？
> 无消费者消费时，消息会丢失。可以使用专业的消息队列，如RibbitMQ、RocketMQ等。

### Q：Redis如何实现延时队列？（选择性掌握）
> 使用`Sorted Set`，拿时间戳作为score，消息内容作为key，调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。

### Q：Redis怎么做持久化的？
> 通过`RDB`和`AOF`做持久化。`RDB做镜像全量持久化`，`AOF做增量持久化`。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。
> 
> RDB：RDB 持久化机制，是对 Redis 中的数据执行周期性的持久化。原理是`fork`和cow`，fork是指redis通过创建子进程来进行RDB操作，cow指的是copy on write（写时复制），子进程创建后，父子进程共享物理数据段，父进程继续提供读写服务，子进程复制时才会真正开辟物理空间。
> 
> AOF：AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的binlog。

### Q：Redis两种持久化机制的优缺点
> 两种方式都可以把Redis内存中的数据持久化到磁盘上，然后再将这些数据备份到别的地方去，RDB更适合做冷备，AOF更适合做热备
> 
> RDB优点：
> 1. 他会生成多个数据文件，每个数据文件分别都代表了某一时刻Redis里面的数据，这种方式，有没有觉得很适合做`冷备`，完整的数据运维设置定时任务，定时同步到远端的服务器，比如阿里的云服务，这样一旦线上挂了，你想恢复多少分钟之前的数据，就去远端拷贝一份之前的数据就好了。
> 2. RDB对Redis的性能影响非常小，是因为在同步数据的时候他只是fork了一个子进程去做持久化的。
> 
> RDB缺点：
> 1. RDB都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。AOF则最多丢一秒的数据，`数据完整性`上高下立判。
> 2. 还有就是RDB在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒，你公司在做秒杀的时候他刚好在这个时候fork了一个子进程去生成一个大快照，哦豁，出大问题。
> 
> AOF优点：
> 1. 相比RDB，数据完整性更好，至多损失1s的数据（如果设置定时刷新为每1s刷新一次的话）
> 
> AOF缺点：
> 1. 同样的数据，AOF会比RDB方式大
> 2. AOF开启后，Redis支持写的QPS会比RDB支持写的要低，他不是每秒都要去异步刷新一次日志嘛fsync，当然即使这样性能还是很高。

### RDB和AOF两种持久化机制怎么选？
> 小孩子才做选择，我全都要，你单独用RDB你会丢失很多数据，你单独用AOF，你数据恢复没RDB来的快，真出什么时候第一时间用RDB恢复，然后AOF做数据补全，真香！冷备热备一起上，才是互联网时代一个高健壮性系统的王道。

### Q：Redis同步机制是怎么回事？
> Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次RDB全量备份，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。

### Redis的key过期策略有了解吗？
> Redis的过期策略，是有`定期删除+惰性删除`两种。
> 1. 定期删除：默认100s就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了。
> 2. 惰性删除：查询这个key的时候再看是否过期，过期则删除。

### Redis的内存淘汰机制有了解吗，小伙子？
> LRU（最近最少被使用）策略，妈的，别往下问了。